/**********************************************************************************************//**
 * @file	Math\PlatformMath.cpp
 *
 * @brief	Implements the platform mathematics class.
 **************************************************************************************************/

/************************************************************************************************************************/
/* Header files inclusion																								*/
/************************************************************************************************************************/
#include "aeCoreStd.h"
#include "PlatformMath.h"

namespace aeCore
{
	/************************************************************************************************************************/
	/* Static variables definition																							*/
	/************************************************************************************************************************/
	static aeRandomNumberGenerator g_RNG;

	/************************************************************************************************************************/
	/* Functions declaration																								*/
	/************************************************************************************************************************/

	/************************************************************************************************************************/
	/** \fn void SRandInit( int32 Seed )
	 * @brief Function to set the initial value of the seed
	 * @param [in] Seed int32 value that will be set as the starting seed
	 */
	 /************************************************************************************************************************/
	void RNGInit(int32 Seed)
	{
		g_RNG.SRand(Seed);
	}

	uint32 UIRand()
	{
		return g_RNG.UIRand();
	}

	int32 IRand()
	{
		return g_RNG.IRand();
	}

	/************************************************************************************************************************/
	/** \fn float FRandU()
	 * @brief	Generates a random float in the range from 0 to 1 using the g_RNG
	 * @return	A float in the range 0-1
	 */
	 /************************************************************************************************************************/
	float FRandU()
	{
		return g_RNG.FRandU();
	}

	/************************************************************************************************************************/
	/** \fn void GaussRandomPair(float& result_a, float& result_b, float dMean, float dStdDeviation)
	 * @brief Generates two random numbers using the polar form of the Box-Muller algorithm
	 *
	 * The polar form of the Box-Muller transformation is able to generate two random Gaussian values on a single pass.\n
	 * This method takes advantage of this situations where lots of random numbers are needed
	 *
	 * @param [out]	result_a Out float for the first generated number
	 * @param [out]	result_b Out float for the second generated number
	 * @param [in]	dMean Minimal value for both generated numbers
	 * @param [in]	dStdDeviation Maximum Standard Deviation value for both numbers
	 * @return		result_a and result_b will contain the generated Gaussian pair
	 */
	 /************************************************************************************************************************/
	void GaussRandomPair(float& result_a, float& result_b, float dMean, float dStdDeviation)
	{
		g_RNG.GaussRandomPair(result_a, result_b, dMean, dStdDeviation);
	}

	/************************************************************************************************************************/
	/** \fn float GaussRandom(float dMean, float dStdDeviation)
	 * @brief Return one Gaussian random number
	 *
	 * This function returns one of the two components generated by the Box-Muller transformation and store the other for a\n
	 * future call (optimization)
	 *
	 * @param [in]	dMean Minimal value for both generated numbers
	 * @param [in]	dStdDeviation Maximum Standard Deviation value for both numbers
	 * @return		A Gaussian random float
	 */
	 /************************************************************************************************************************/
	float GaussRandom(float dMean, float dStdDeviation)
	{
		return g_RNG.GaussRandom(dMean, dStdDeviation);
	}

	double ZigguratRandom()
	{
		return g_RNG.Zigg();
	}

	double ZigguratNRandom()
	{
		return g_RNG.ZiggN();
	}

	int32 RandHelper(int32 A)
	{
		return g_RNG.RandHelper(A);
	}

	int32 RandRange(int32 Min, int32 Max)
	{
		return g_RNG.RandRange(Min,Max);
	}

	float FRandRange(float InMin, float InMax)
	{
		return g_RNG.FRandRange(InMin,InMax);
	}

	/**********************************************************************************************//**
	 * @fn	aePoint GetMapToScreenCoords(aeVector2 Point, aeVector2 CameraPosition, aeRect ScreenPrecalc, bool Isometric)
	 *
	 * @brief	Gets map to screen coordinates.
	 *
	 * @param	Point		  	The point to be processed.
	 * @param	CameraPosition	The camera position.
	 * @param	ScreenPrecalc 	The screen pre-calculations, in which, the x and y values must be the
	 * 							world window defacement, and the w and h must be half of the world
	 * 							window w and h.
	 * @param	Isometric	  	true if the world is isometric.
	 *
	 * @return	The map to screen coordinates.
	 **************************************************************************************************/

	aePoint GetMapToScreenCoords(aeVector2 Point, aeVector2 CameraPosition, aeRect ScreenPrecalc, bool Isometric)
	{
		//Zero we create the ScreenCoords that will be returned.
		aePoint ScreenCoords;
		//First we subtract the camera position to the point.
		Point -= CameraPosition;
		//Second we convert the given point from the world axis to the screen axis.
		Point.x = Point.x + ScreenPrecalc.w;
		Point.y = (-Point.y) + ScreenPrecalc.h; //we put them in this order due to the possible loss of data in the subtraction
												//Third we set the world window defacement of the screen to the ScreenCoords.
		ScreenCoords.x = ScreenPrecalc.x;
		ScreenCoords.y = ScreenPrecalc.y;
		//Fourth we check if the map is isometric
		if (Isometric)
		{//If the world is isometric, we use the isometric equations to convert x and y.
			ScreenCoords.x += static_cast<int>(Point.x - Point.y);
			ScreenCoords.y += static_cast<int>((Point.x + Point.y)*0.5f);
		}
		else
		{//If the world is not isometric, we add the point to the ScreenCoords
			ScreenCoords.x += static_cast<int>(Point.x);
			ScreenCoords.y += static_cast<int>(Point.y);
		}
		//Finally we return the ScreenCoords
		return ScreenCoords;
	}

	/**********************************************************************************************//**
	 * @fn	aeVector2 GetScreenToMapCoords(aePoint Point, aeVector2 CameraPosition, aeRect ScreenPrecalc, bool Isometric)
	 *
	 * @brief	Gets screen to map coordinates.
	 *
	 * @param	Point		  	The point to be processed.
	 * @param	CameraPosition	The camera position.
	 * @param	ScreenPrecalc 	The screen pre-calculations, in which, the x and y values must be the
	 * 							world window defacement, and the w and h must be half of the world
	 * 							window w and h.
	 * @param	Isometric	  	true if the world is isometric.
	 *
	 * @return	The screen to map coordinates.
	 **************************************************************************************************/

	aeVector2 GetScreenToMapCoords(aePoint Point, aeVector2 CameraPosition, aeRect ScreenPrecalc, bool Isometric)
	{
		//Zero we create the MapCoords that will be returned.
		aeVector2 MapCoords;
		//First we remove the world window defacement of the point.
		Point.x -= ScreenPrecalc.x;
		Point.y -= ScreenPrecalc.y;
		//Second we convert the given point from the screen axis to the world axis.
		Point.x = Point.x - ScreenPrecalc.w;
		Point.y = ScreenPrecalc.h - Point.y;
		//Third we check if the map is isometric
		if (Isometric)
		{//If the world is isometric, we use the isometric equations to convert x and y
			MapCoords.x = ((float)Point.y + (float)Point.x*0.5f);
			MapCoords.y = ((float)Point.y - (float)Point.x*0.5f);
		}
		else
		{//If the world is not isometric, we set the point to the MapCoords.
			MapCoords.x = static_cast<float>(Point.x);
			MapCoords.y = static_cast<float>(Point.y);
		}
		//Forth we add to the camera position to the map coordinates
		MapCoords += CameraPosition;
		//Finally we return the MapCoords
		return MapCoords;
	}

	float Lerp(float Start, float End, float Porcentage)
	{//Linear interpolation
		return Start + Porcentage*(End - Start);
	}

	float Grad(int hash, float x, float y, float z)
	{
		int h = hash & 15;                                    // Take the hashed value and take the first 4 bits of it (15 == 0b1111)
		float u = h < 8 /* 0b1000 */ ? x : y;                // If the most significant bit (MSB) of the hash is 0 then set u = x.  Otherwise y.

		float v;                                             // In Ken Perlin's original implementation this was another conditional operator (?:).  I
															  // expanded it for readability.

		if (h < 4 /* 0b0100 */)                                // If the first and second significant bits are 0 set v = y
			v = y;
		else if (h == 12 /* 0b1100 */ || h == 14 /* 0b1110*/)  // If the first and second significant bits are 1 set v = x
			v = x;
		else                                                  // If the first and second significant bits are not equal (0/1, 1/0) set v = z
			v = z;

		return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v); // Use the last 2 bits to decide if u and v are positive or negative.  Then return their addition.
	}

	float Fade(float t) 
	{
		// Fade function as defined by Ken Perlin.  This eases coordinate values
		// so that they will ease towards integral values.  This ends up smoothing
		// the final output.
		return t * t * t * (t * (t * 6 - 15) + 10);         // 6t^5 - 15t^4 + 10t^3
	}
}